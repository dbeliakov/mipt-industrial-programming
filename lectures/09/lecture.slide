# Промышленное программирование

Лекция 9. CI/CD

## Системы сборки

* В большинстве проектов, с которыми вы взаимодействуете как разработчик, так или иначе имеют этап сборки
* Для сборки (или тестирования, например) может потребоваться выполнить большое количество действий - например, сгенерировать код файлам описания, собрать .so с какой-либо библиотекой, обновить зависимые компоненты, собрать биндинг для своего языка, собрать итоговый проект, ...
* Существует большое количество систем сборки, которые помогают управлять всеми этапами, необходимыми для получения результата

## Системы сборки

* Системы сборки могут быть сильно разными в зависимости от требований, но суть их работы примерно одна и та же
* Для системы сборки есть набор зависимостей, набор целей, и набор правил, как из одного получить другое
* Вы говорите системе сборки, что хотите получить, а она уже анализирует зависимости и знает, что и как нужно сделать чтобы получить результат. В идеале, для зависимостей, собранных однажды и не изменившихся, она должна переиспользовать результат

## make

* make - вероятно, самая распространенная система сборки, предустанавливается на большинстве ОС семейства UNIX
* make можно посчитать достаточно простым, однако, с его помощью можно строить очень сложные сценарии сборки
* Цели, зависимости и правила описываются в Makefile

        paper.pdf: paper.tex plot-data.png
                pdflatex paper.tex

        plot-%.png: %.dat plot.py
                ./plot.py -i $*.dat -o $@

* Первая цель в Makefile - цель по умолчанию. Для ее сборки можно просто позвать `make`
* Можно позвать определенную цель: `make plot-data.png`

## Управление зависимостями

* Современную разработку сложно представить без использования сторонних библиотек и инструментов
* Для версионирования зависимостей используется, зачастую, semantic versioning
* Сами зависимости распространяются через различные репозитории (pipy, npm, apt, brew, ...)
* Для разрешения зависимостей существует большое количество инструментов
* Обычно, зависимости указываются с некоторым набором ограничений - например, мажорная версия 1, минорная и фик версии - любые
* При этом у зависимостей так же могут быть зависимости, и, например, где-то будет указана необходимая минорная версия
* Обычно, кроме правил, есть фиксированный набор зависимостей (в lock файле), либо же определенные зависимости лежат уже рядом в репозитории

## Continuous Integration

* Непрерывная интеграция - подход к разработке приложений, подразумевающий частое проведение сборок проекта и тестирование кода
* Цель — сделать процесс интеграции предсказуемым и обнаружить потенциальные баги и ошибки на ранней стадии, чтобы было больше времени на их исправление
* Впервые термин Continuous Integration появился в 1991 году (Гради Буч, создатель языка UML)
* Он подразумевал инкрементальное уточнение архитектуры при проектировании объектно-ориентированных систем
* Позже в своей книге "Object-Oriented Analysis and Design with Applications" он сказал, что задача методики — ускорить выпуск «внутренних релизов»

## Continuous Integration

* В начале 2000-х методологию непрерывной интеграции стал продвигать один из основателей Agile Alliance Мартин Фаулер
* Его эксперименты с CI привели к появлению первого программного инструмента в этой сфере — CruiseControl
* Цикл сборки в инструменте реализован в виде демона, периодически проверяющего систему управления версиями на изменения в кодовой базе

## Continuous Integration

* Основу непрерывной интеграции составляют два инструмента — система контроля версий и CI-сервер
* Разработчики один или несколько раз в день загружают новый код
* CI-сервер автоматически копирует его со всеми зависимости и выполняет сборку и тестирование

## Принципы CI

* **Немедленно исправлять проблемы.** Этот принцип пришёл в CI из [экстремального программирования](https://en.wikipedia.org/wiki/Extreme_programming). Исправление багов — самая приоритетная задача разработчиков
* **Автоматизировать процессы.** Разработчики и менеджеры должны постоянно искать «узкие места» в процессе интеграции и устранять их. Например, часто «бутылочным горлышком» интеграции оказывается тестирование
* **Проводить сборки как можно чаще.** Раз в день, чтобы синхронизировать работу команды.

## Сложности внедрения

* Высокие операционные расходы - на поддержку инфраструктуры большого проекта требуется много человеко-часов
* Непрерывная интеграция повышает нагрузку на сотрудников компании (по крайней мере первое время)
* Есть много legacy-проектов, не покрытых автотестами. Бывает, что код надо полностью переписать для полноценного внедрения CI

## Инструменты CI

* [Jenkins](https://www.jenkins.io/)
* [GitLab CI](https://docs.gitlab.com/ee/ci/)
* [Drone CI](https://www.drone.io/)
* [Teamcity](https://www.jetbrains.com/ru-ru/teamcity/)
* [GitHub Actions](https://github.com/features/actions)

## CI системы

.image img/ci-cloud.jpeg

## GitHub Actions

* Workflow - автоматизированная процедура, добавляемая в репозиторий. Может состоять из нескольких задач, которые запускаются по какому-либо событию
* Event - специфичное событие, которое тригерит workflow. Список возможных событий
* Job - набор шагов, выполняемых последовательно или параллельно. Job может зависить от результата выполнения другой
* Step - индивидуальная задача, которая запускает команду (action). Данные от предыдущего шага доступны в последующих
* Action - набор шагов, который можно использовать как "кирпичик" в своем workflow
* Runner - сервер, на котором установлено соответствующее ПО для запуска задач. Может быть GitHub-hosted и self-hosted

## GitHub Actions

        name: learn-github-actions
        on: [push]
        jobs:
        check-bats-version:
        runs-on: ubuntu-latest
        steps:
        - uses: actions/checkout@v2
        - uses: actions/setup-node@v1
        - run: npm install -g bats
        - run: bats -v