
<!DOCTYPE html>
<html>
  <head>
    <title>Промышленное программирование</title>
    <meta charset='utf-8'>
    <link rel="icon" href="static/favicon.ico">
    <script>
      var notesEnabled =  false ;
    </script>
    <script src='static/slides.js'></script>

    

    <script>
      
      if (window["location"] && window["location"]["hostname"] == "talks.golang.org") {
        var _gaq = _gaq || [];
        _gaq.push(["_setAccount", "UA-11222381-6"]);
        _gaq.push(["b._setAccount", "UA-49880327-6"]);
        window.trackPageview = function() {
          _gaq.push(["_trackPageview", location.pathname+location.hash]);
          _gaq.push(["b._trackPageview", location.pathname+location.hash]);
        };
        window.trackPageview();
        window.trackEvent = function(category, action, opt_label, opt_value, opt_noninteraction) {
          _gaq.push(["_trackEvent", category, action, opt_label, opt_value, opt_noninteraction]);
          _gaq.push(["b._trackEvent", category, action, opt_label, opt_value, opt_noninteraction]);
        };
      }
    </script>
  </head>

  <body style='display: none'>

    <section class='slides layout-widescreen'>

      <article>
        <h1>Промышленное программирование</h1>
        
        
        
          <div class="presenter">
            
  
  <p>
    Лекция 9. CI/CD
  </p>
  

          </div>
        
      </article>

  
  
      <article >
      
        <h3>Системы сборки</h3>
        <ul>
<li>В большинстве проектов, с которыми вы взаимодействуете как разработчик, так или иначе имеют этап сборки</li>
<li>Для сборки (или тестирования, например) может потребоваться выполнить большое количество действий - например, сгенерировать код файлам описания, собрать .so с какой-либо библиотекой, обновить зависимые компоненты, собрать биндинг для своего языка, собрать итоговый проект, ...</li>
<li>Существует большое количество систем сборки, которые помогают управлять всеми этапами, необходимыми для получения результата</li>
</ul>

      
      <span class="pagenumber">2</span>
      </article>
  
  
  
      <article >
      
        <h3>Системы сборки</h3>
        <ul>
<li>Системы сборки могут быть сильно разными в зависимости от требований, но суть их работы примерно одна и та же</li>
<li>Для системы сборки есть набор зависимостей, набор целей, и набор правил, как из одного получить другое</li>
<li>Вы говорите системе сборки, что хотите получить, а она уже анализирует зависимости и знает, что и как нужно сделать чтобы получить результат. В идеале, для зависимостей, собранных однажды и не изменившихся, она должна переиспользовать результат</li>
</ul>

      
      <span class="pagenumber">3</span>
      </article>
  
  
  
      <article >
      
        <h3>make</h3>
        <ul>
<li>
<p>make - вероятно, самая распространенная система сборки, предустанавливается на большинстве ОС семейства UNIX</p>
</li>
<li>
<p>make можно посчитать достаточно простым, однако, с его помощью можно строить очень сложные сценарии сборки</p>
</li>
<li>
<p>Цели, зависимости и правила описываются в Makefile</p>
<pre><code>  paper.pdf: paper.tex plot-data.png
          pdflatex paper.tex

  plot-%.png: %.dat plot.py
          ./plot.py -i $*.dat -o $@
</code></pre>
</li>
<li>
<p>Первая цель в Makefile - цель по умолчанию. Для ее сборки можно просто позвать <code>make</code></p>
</li>
<li>
<p>Можно позвать определенную цель: <code>make plot-data.png</code></p>
</li>
</ul>

      
      <span class="pagenumber">4</span>
      </article>
  
  
  
      <article >
      
        <h3>Управление зависимостями</h3>
        <ul>
<li>Современную разработку сложно представить без использования сторонних библиотек и инструментов</li>
<li>Для версионирования зависимостей используется, зачастую, semantic versioning</li>
<li>Сами зависимости распространяются через различные репозитории (pipy, npm, apt, brew, ...)</li>
<li>Для разрешения зависимостей существует большое количество инструментов</li>
<li>Обычно, зависимости указываются с некоторым набором ограничений - например, мажорная версия 1, минорная и фик версии - любые</li>
<li>При этом у зависимостей так же могут быть зависимости, и, например, где-то будет указана необходимая минорная версия</li>
<li>Обычно, кроме правил, есть фиксированный набор зависимостей (в lock файле), либо же определенные зависимости лежат уже рядом в репозитории</li>
</ul>

      
      <span class="pagenumber">5</span>
      </article>
  
  
  
      <article >
      
        <h3>Continuous Integration</h3>
        <ul>
<li>Непрерывная интеграция - подход к разработке приложений, подразумевающий частое проведение сборок проекта и тестирование кода</li>
<li>Цель — сделать процесс интеграции предсказуемым и обнаружить потенциальные баги и ошибки на ранней стадии, чтобы было больше времени на их исправление</li>
<li>Впервые термин Continuous Integration появился в 1991 году (Гради Буч, создатель языка UML)</li>
<li>Он подразумевал инкрементальное уточнение архитектуры при проектировании объектно-ориентированных систем</li>
<li>Позже в своей книге &quot;Object-Oriented Analysis and Design with Applications&quot; он сказал, что задача методики — ускорить выпуск «внутренних релизов»</li>
</ul>

      
      <span class="pagenumber">6</span>
      </article>
  
  
  
      <article >
      
        <h3>Continuous Integration</h3>
        <ul>
<li>В начале 2000-х методологию непрерывной интеграции стал продвигать один из основателей Agile Alliance Мартин Фаулер</li>
<li>Его эксперименты с CI привели к появлению первого программного инструмента в этой сфере — CruiseControl</li>
<li>Цикл сборки в инструменте реализован в виде демона, периодически проверяющего систему управления версиями на изменения в кодовой базе</li>
</ul>

      
      <span class="pagenumber">7</span>
      </article>
  
  
  
      <article >
      
        <h3>Continuous Integration</h3>
        <ul>
<li>Основу непрерывной интеграции составляют два инструмента — система контроля версий и CI-сервер</li>
<li>Разработчики один или несколько раз в день загружают новый код</li>
<li>CI-сервер автоматически копирует его со всеми зависимости и выполняет сборку и тестирование</li>
</ul>

      
      <span class="pagenumber">8</span>
      </article>
  
  
  
      <article >
      
        <h3>Принципы CI</h3>
        <ul>
<li><strong>Немедленно исправлять проблемы.</strong> Этот принцип пришёл в CI из <a href="https://en.wikipedia.org/wiki/Extreme_programming" target="_blank" rel="noopener">экстремального программирования</a>. Исправление багов — самая приоритетная задача разработчиков</li>
<li><strong>Автоматизировать процессы.</strong> Разработчики и менеджеры должны постоянно искать «узкие места» в процессе интеграции и устранять их. Например, часто «бутылочным горлышком» интеграции оказывается тестирование</li>
<li><strong>Проводить сборки как можно чаще.</strong> Раз в день, чтобы синхронизировать работу команды.</li>
</ul>

      
      <span class="pagenumber">9</span>
      </article>
  
  
  
      <article >
      
        <h3>Сложности внедрения</h3>
        <ul>
<li>Высокие операционные расходы - на поддержку инфраструктуры большого проекта требуется много человеко-часов</li>
<li>Непрерывная интеграция повышает нагрузку на сотрудников компании (по крайней мере первое время)</li>
<li>Есть много legacy-проектов, не покрытых автотестами. Бывает, что код надо полностью переписать для полноценного внедрения CI</li>
</ul>

      
      <span class="pagenumber">10</span>
      </article>
  
  
  
      <article >
      
        <h3>Инструменты CI</h3>
        <ul>
<li><a href="https://www.jenkins.io/" target="_blank" rel="noopener">Jenkins</a></li>
<li><a href="https://docs.gitlab.com/ee/ci/" target="_blank" rel="noopener">GitLab CI</a></li>
<li><a href="https://www.drone.io/" target="_blank" rel="noopener">Drone CI</a></li>
<li><a href="https://www.jetbrains.com/ru-ru/teamcity/" target="_blank" rel="noopener">Teamcity</a></li>
<li><a href="https://github.com/features/actions" target="_blank" rel="noopener">GitHub Actions</a></li>
</ul>

      
      <span class="pagenumber">11</span>
      </article>
  
  
  
      <article >
      
        <h3>CI системы</h3>
        
<div class="image">
  <img src="img/ci-cloud.jpeg">
</div>

      
      <span class="pagenumber">12</span>
      </article>
  
  
  
      <article >
      
        <h3>GitHub Actions</h3>
        <ul>
<li>Workflow - автоматизированная процедура, добавляемая в репозиторий. Может состоять из нескольких задач, которые запускаются по какому-либо событию</li>
<li>Event - специфичное событие, которое тригерит workflow. Список возможных событий</li>
<li>Job - набор шагов, выполняемых последовательно или параллельно. Job может зависить от результата выполнения другой</li>
<li>Step - индивидуальная задача, которая запускает команду (action). Данные от предыдущего шага доступны в последующих</li>
<li>Action - набор шагов, который можно использовать как &quot;кирпичик&quot; в своем workflow</li>
<li>Runner - сервер, на котором установлено соответствующее ПО для запуска задач. Может быть GitHub-hosted и self-hosted</li>
</ul>

      
      <span class="pagenumber">13</span>
      </article>
  
  
  
      <article >
      
        <h3>GitHub Actions</h3>
        <pre><code>    name: learn-github-actions
    on: [push]
    jobs:
    check-bats-version:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - uses: actions/setup-node@v1
    - run: npm install -g bats
    - run: bats -v</code></pre>

      
      <span class="pagenumber">14</span>
      </article>
  
  
  
      <article >
      
        <h3>Continuous delivery</h3>
        <ul>
<li>Непрерывная поставка (Continuous Delivery) — это подход к разработке программного обеспечения, при котором все изменения, включая новые функции, изменения конфигурации, исправления ошибок и эксперименты, поставляются пользователям максимально быстро и безопасно</li>
<li>Любой, кто обладает достаточными привилегиями для развертывания нового релиза может выполнить развертывание в любой момент, и это можно сделать в несколько кликов</li>
<li>Программист, избавившись практически от всей ручной работы, трудится продуктивнее</li>
</ul>

      
      <span class="pagenumber">15</span>
      </article>
  
  
  
      <article >
      
        <h3>Continuous delivery</h3>
        <ol>
<li>Разработчик отправляет свои изменения в систему контроля версии</li>
<li>На сервере сборки начинается процесс сборки поступивших изменений</li>
<li>Запускаются тесты</li>
<li>Собранный пакет после успешной интеграции выкладывается на тестовый сервер</li>
<li>Заинтересованные лица получают уведомления о выкладке новой версии ПО на тестовую площадку. Начинается вторая фаза тестирования, запускаются интеграционные, ручные, приемочные, UI тесты и тд</li>
<li>После успешного прохождения предыдущих шагов мы имеем готовый к публикации пакет новой версии ПО</li>
</ol>

      
      <span class="pagenumber">16</span>
      </article>
  
  
  
      <article >
      
        <h3>Continuous delivery</h3>
        <ul>
<li>Очень важно отметить, что на протяжении всего процесса непрерывной доставки команда постоянно получает обратную связь</li>
<li>Непрерывная поставка позволяет нам снизить риски релизов, делая развертывание программного обеспечения безболезненным, безопасным событием, которое может быть выполнено в любое время</li>
<li>Автоматизируя большинство операций, таких как развертывание, настройки окружения, тестирование, мы сокращаем время поставки новой функциональности</li>
</ul>

      
      <span class="pagenumber">17</span>
      </article>
  
  
  
      <article >
      
        <h3>Continuous deployment</h3>
        <ul>
<li>Непрерывное развертывание (deployment) располагается «на уровень выше» непрерывной доставки</li>
<li>Все изменения, вносимые в исходный код, автоматически развертываются в продакшен, без явной отмашки от разработчика</li>
<li>Как правило, задача разработчика сводится к проверке запроса на включение (pull request) от коллеги и к информированию команды о результатах всех важных событий</li>
<li>Непрерывное развертывание требует, чтобы в команде существовала отлаженная культура мониторинга, все умели держать руку на пульсе и быстро восстанавливать систему</li>
</ul>

      
      <span class="pagenumber">18</span>
      </article>
  
  
  
      <article >
      
        <h3>Continuous deployment</h3>
        <ul>
<li>Иногда возникает путаница, что означает аббревиатура «CD» в паре «CI/CD». Четкого ответа на этот вопрос нет, но в большинстве случаев эта пара понимается как «непрерывная интеграция и непрерывная доставка»</li>
<li>Это логично, если учесть, что непрерывное развертывание – частный случай непрерывной доставки, применимый не в каждой системе</li>
</ul>

      
      <span class="pagenumber">19</span>
      </article>
  
  
  
      <article >
      
        <h3>Docker</h3>
        <ul>
<li>Docker – open–source движок, автоматизирующий развертывание приложений в легковесные, переносимые, самодостаточные контейнеры, которые могут без изменений переноситься между серверами</li>
<li>Он крайне легок в управлении, расширении, миграции и подходит для огромного спектра задач начиная от разработки приложений и сборки пакетов и заканчивая тестами-пятиминутками</li>
<li>Тот же самый контейнер, который разработчик создает и тестирует на ноутбуке, может быть легко перенесен на продакшн-сервера в облако и так же легко смигрирован в другой регион при необходимости</li>
</ul>

      
      <span class="pagenumber">20</span>
      </article>
  
  
  
      <article >
      
        <h3>Docker</h3>
        <ul>
<li>Docker — средство изоляции процесса(задачи), а это значит относиться к докеру как к виртуалке нельзя</li>
<li>Но он имеет многие похожие фишки, как и у виртуализации: независимость (контейнер может быть перемещен на любую ОС с docker-службой на борту и контейнер будет работать) и самодостаточность (контейнер будет выполнять свои функции в любом месте, где бы его не запустили)</li>
<li>Внутри контейнера находится минимально необходимый набор софта, необходимый для работы вашего процесса. Это уже не полноценная ОС, которую надо мониторить, следить за остатком места, ...</li>
<li>Контейнер это инструмент обработки данных, но не инструмент их хранения. Данные не должны сохраняться внутри контейнера</li>
</ul>

      
      <span class="pagenumber">21</span>
      </article>
  
  
  
      <article >
      
        <h3>Docker</h3>
        <ul>
<li>Контейнер живет, пока живет процесс, вокруг которого рождается контейнер</li>
<li>Внутри контейнера этот процесс имеет pid=1</li>
<li>Рядом с процессом с pid=1 можно порождать сколько угодно других процессов, но убив (рестартовав) именно процесс с pid=1, контейнер выходит</li>
<li>Данные, создаваемые внутри контейнера остаются в контейнере и нигде более не сохраняются. Удалив контейнер — потеряете все ваши изменения. Поэтому данные в контейнерах не хранят, а выносят наружу, на хостовую ОС</li>
</ul>

      
      <span class="pagenumber">22</span>
      </article>
  
  
  
      <article >
      
        <h3>Docker</h3>
        <ul>
<li>Docker – клиент-серверное приложение. Клиенты разговаривают с сервером (демоном), который непосредственно делает всю работу</li>
<li>Для управления Docker можно использовать утилиту командной строки docker и RESTful API</li>
<li>Можно запускать клиент и сервер на одном хосте или удаленно подключаться к Docker-серверу</li>
</ul>

      
      <span class="pagenumber">23</span>
      </article>
  
  
  
      <article >
      
        <h3>Образы</h3>
        <ul>
<li>Свои контейнеры пользователь запускает из образов, которые являются частью процесса построения контейнера</li>
<li>Docker хранит созданные вами образы в реестрах</li>
<li>Существует два типа реестров: публичные и приватные. Официальный реестр называется Docker Hub</li>
<li>Создав в нем аккаунт, можно сохранять свои образы в нем и делиться ими с другими пользователями</li>
</ul>

      
      <span class="pagenumber">24</span>
      </article>
  
  
  
      <article >
      
        <h3>Контейнеры</h3>
        <ul>
<li>Контейнер - аналог процесса, только представляет собой приложение в совокупности. Контейнеры запускаются из образов</li>
<li>Когда Docker запускает контейнер, слой для записи пуст. При изменениях они записываются в этот слой. Например при изменении файла он копируется в слой, доступный для записи (copy on write)</li>
</ul>

      
      <span class="pagenumber">25</span>
      </article>
  
  
  
      <article >
      
        <h3>Dockerfile</h3>
        <ul>
<li>Описание шагов по построению образа</li>
<li>Каждый шаг - новый слой</li>
<li>Сборка образа - <code>docker build -t [NAME]:[TAG] .</code> (в директории с Dockerfile)</li>
</ul>

      
      <span class="pagenumber">26</span>
      </article>
  
  
  
      <article >
      
        <h3>Docker compose</h3>
        <ul>
<li>Docker Compose — это инструментальное средство, входящее в состав Docker. Оно предназначено для решения задач, связанных с развёртыванием проектов</li>
<li>На практике реальные проекты состоят из большого количества связанных друг с другом контейнеров</li>
<li>Технология Docker Compose, если описывать её упрощённо, позволяет, с помощью одной команды, запускать множество сервисов</li>
</ul>

      
      <span class="pagenumber">27</span>
      </article>
  
  
  
      <article >
      
        <h3>Kubernetes</h3>
        <ul>
<li>Kubernetes является проектом с открытым исходным кодом, предназначенным для управления кластером контейнеров как единой системой</li>
<li>Kubernetes управляет и запускает контейнеры Docker на большом количестве хостов, а так же обеспечивает совместное размещение и репликацию большого количества контейнеров</li>
<li>Предлагается высокоуровневый API, определяющее логическое группирование контейнеров, позволяющее определять пулы контейнеров, балансировать нагрузку, а также задавать их размещение</li>
</ul>

      
      <span class="pagenumber">28</span>
      </article>
  
  
  
      <article >
      
        <h3>Kubernetes</h3>
        <ul>
<li><strong>Pod (под)</strong> - это группа из одного или более контейнера с общим хранилищем/сетевыми ресурсами и спецификацией как запускать контейнеры. Так же это отдельный инстанс приложения. Размещая контейнеры таким образом, Kubernetes устраняет соблазн втиснуть слишком много функций в один образ контейнера</li>
<li><strong>Service (Сервис)</strong> в Kubernetes используется для группирования нескольких подов, которые выполняют те же функции. Сервисы легко настраиваются для таких целей как обнаружение, горизонтальное масштабирование и балансировка нагрузки</li>
</ul>

      
      <span class="pagenumber">29</span>
      </article>
  
  
  
      <article >
      
        <h3>Kubernetes</h3>
        <ul>
<li>Возможность обнаружения контейнеров</li>
<li>Автоматическое развертывание и откаты</li>
<li>Автоматическое распределение нагрузки</li>
<li>Самоконтроль</li>
<li>Управление секретами</li>
</ul>

      
      <span class="pagenumber">30</span>
      </article>
  
  

      <article>
        <h3>Thank you</h3>
        
          <div class="presenter">
            
  
  <p>
    Лекция 9. CI/CD
  </p>
  

          </div>
        
      </article>

    </section>

    <div id="help">
      Use the left and right arrow keys or click the left and right
      edges of the page to navigate between slides.<br>
      (Press 'H' or navigate to hide this message.)
    </div>

    
    <script src='static/jquery.js'></script>
    <script src='static/jquery-ui.js'></script>
    <script src='static/playground.js'></script>
    <script src='static/play.js'></script>
    <script>initPlayground(new HTTPTransport());</script>
    

    <script>
      (function() {
        
        if (window["location"] && window["location"]["hostname"] == "talks.golang.org") {
          var ga = document.createElement("script"); ga.type = "text/javascript"; ga.async = true;
          ga.src = ("https:" == document.location.protocol ? "https://ssl" : "http://www") + ".google-analytics.com/ga.js";
          var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(ga, s);
        }
      })();
    </script>
  </body>
</html>
