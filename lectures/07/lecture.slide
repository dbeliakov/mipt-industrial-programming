# Промышленное программирование

Лекция 7. Тестирование

## Тестирование

Заходит однажды тестировщик в бар. Забегает в бар. Пролезает в бар. Танцуя, проникает в бар. Крадется в бар. Врывается в бар. Прыгает в бар

и заказывает:

кружку пива, 2 кружки пива, 0 кружек пива, 999999999 кружек пива, ящерицу в стакане, –1 кружку пива, qwertyuip кружек пива.

## Цели тестирования

* Тестирование ПО — проверка соответствия реальных и ожидаемых результатов поведения программы, проводимая на конечном наборе тестов, выбранном определённым образом.
* Цель тестирования — проверка соответствия ПО предъявляемым требованиям, обеспечение уверенности в качестве ПО, поиск очевидных ошибок в программном обеспечении, которые должны быть выявлены до того, как их обнаружат пользователи программы.

## Цели тестирования

Тестирование ПО производится:
* Для проверки соответствия требованиям.
* Для обнаружение проблем на более ранних этапах разработки и предотвращение повышения стоимости продукта.
* Обнаружение вариантов использования, которые не были предусмотрены при разработке. А также взгляд на продукт со стороны пользователя.
* Повышение лояльности к компании и продукту, т.к. любой обнаруженный дефект негативно влияет на доверие пользователей.

## Принципы тестирования

* Тестирование демонстрирует наличие дефектов
* Исчерпывающее тестирование невозможно
* Раннее тестирование
* Скопление дефектов
* Парадокс пестицида
* Тестирование зависит от контекста
* Заблуждение об отсутствии ошибок

## Отчет об ошибке

* Уникальный идентификатор (ID) — присваивается автоматически системой при создании баг-репорта.
* Тема (краткое описание, Summary) — кратко сформулированный смысл дефекта, отвечающий на вопросы: Что? Где? Когда(при каких условиях)?
* Подробное описание (Description) — более широкое описание дефекта (указывается опционально).
* Шаги для воспроизведения (Steps To Reproduce) — описание четкой последовательности действий, которая привела к выявлению дефекта. В шагах воспроизведения должен быть описан каждый шаг, вплоть до конкретных вводимых значений, если они играют роль в воспроизведении дефекта.
* Фактический результат (Actual result) — описывается поведение системы на момент обнаружения дефекта в ней. чаще всего, содержит краткое описание некорректного поведения(может совпадать с темой отчета о дефекте).

## Отчет об ошибке

* Ожидаемый результат (Expected result) — описание того, как именно должна работать система в соответствии с документацией.
* Вложения (Attachments) — скриншоты, видео или лог-файлы.
* Серьёзность дефекта (важность, Severity) — характеризует влияние дефекта на работоспособность приложения.
* Приоритет дефекта (срочность, Priority) — указывает на очерёдность выполнения задачи или устранения дефекта.
* Статус (Status) — определяет текущее состояние дефекта. Статусы дефектов могут быть разными в разных баг-трекинговых системах.
* Окружение (Environment) – окружение, на котором воспроизвелся баг.

## Окружения проекта

* Development - за данную среду отвечают разработчики, в ней они пишут код, проводят отладку, исправляют ошибки
* Testing - среда, в которой работают тестировщики (проверяют функционал, проводят smoke и регрессионные тесты, воспроизводят.
* Integration - среда, в которой проводят тестирование взаимодействующих друг с другом модулей, систем, продуктов.
* Preprod - среда, которая максимально приближена к продакшену. Здесь проводится заключительное тестирование функционала.
* Production - среда, в которой работают пользователи.

## Классификация

* Статическое тестирование
* Динамическое тестирование

## Классификация

* Белый ящик
* Серый ящик
* Черный ящик

## Классификация

* Модульное тестирование
* Интеграционное тестирование
* Системное тестирование
* Приёмочное тестирование

## Классификация

* Ручное тестирование (своими силами или с привлечением QA)
* Автоматизированное тестирование

## Классификация

* Позитивное тестирование
* Негативное тестирование

## Классификация

* Функциональное тестирование
* Нефункциональное тестирование
    * performance, load, stress, scalability...
    * UI, usability, localization, ...
    * security

## Тест-кейсы

* Тестирование на основе классов эквивалентности (equivalence partitioning)
* Техника анализа граничных значений (boundary value testing)
* Попарное тестирование (pairwise testing)
* Тестирование на основе состояний и переходов (State-Transition Testing)
* Таблицы принятия решений (Decision Table Testing)
* Доменный анализ (Domain Analysis Testing)
* Сценарий использования (Use Case Testing)

## Code coverage

* Одна из распространенных методик оценки "насколько хорошо протестирован пакет"
* При запуске тестов просчитывается, какие строки кода исполнялись (и, возможно, сколько раз)
* Хорошее покрытие кода тестами абсолютно не означает, что код не содержит багов
* Тем не менее, хорошо покрытый тестами код с большей вероятностью работает стабильно и
делает то, что от него ожидают, в важных кейсах
* Зачастую в популярных пакетах можно встретить `code coverage` порядка 80-90%. Это отличный показатель,
так как из-за явной обработки ошибок появляется много строк кода, исполнение которых маловероятно и тяжело для тестирования

## Тестирование ПО

* Python: [unittest](https://docs.python.org/3/library/unittest.html), [PyTest](https://docs.pytest.org/en/6.2.x/), [PyTest for Machine Learning](https://towardsdatascience.com/pytest-for-machine-learning-a-simple-example-based-tutorial-a3df3c58cf8)
* C++: [Boost.Test](https://www.boost.org/doc/libs/1_75_0/libs/test/doc/html/index.html), [GoogleTest](https://github.com/google/googletest)
* GoLang: `go test` + [полезные пакеты](https://github.com/dbeliakov/mipt-golang-course/blob/master/lectures/07/lecture_07.slide#L86)
* Нагрузочное тестирование: [Яндекс.Танк](https://yandex.ru/dev/tank/), [JMeter](https://jmeter.apache.org/), [k6](https://github.com/grafana/k6)
* ...